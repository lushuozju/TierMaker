# 遮罩功能代码文档

本文档整理了项目中所有与遮罩功能相关的代码，包括图片预览遮罩和白框实现。

---

## 文件列表

1. **src/components/EditItemModal.vue** - 编辑作品模态框，包含图片预览遮罩功能
2. **src/components/SearchModal.vue** - 搜索模态框，包含搜索结果白框实现

---

## 1. EditItemModal.vue - 图片预览遮罩功能

### 1.1 变量定义

```typescript
// 第 27-29 行
const originalImageRef = ref<HTMLImageElement | null>(null)
const previewMaskStyle = ref<{ [key: string]: string }>({})
const overlayStyle = ref<{ [key: string]: string }>({})
```

### 1.2 核心函数：updatePreviewCrop()

```typescript
// 第 48-195 行
// 更新预览图片的裁剪位置
function updatePreviewCrop() {
  if (!imagePreview.value) return
  
  const originalImg = originalImageRef.value
  if (!originalImg) return
  
  // 等待图片加载完成
  if (!originalImg.complete) return
  if (!originalImg.naturalWidth || !originalImg.naturalHeight) return

  const naturalWidth = originalImg.naturalWidth
  const naturalHeight = originalImg.naturalHeight
  const naturalRatio = naturalWidth / naturalHeight
  const targetRatio = 0.75 // 3:4
  const previewWidth = 100
  const previewHeight = 133
  
  // 确定裁剪位置
  let cropPos = previewCropPosition.value
  if (cropPos === 'auto') {
    // 自动模式：根据图片宽高比决定
    if (naturalRatio < targetRatio) {
      cropPos = 'center top'
    } else {
      cropPos = 'center center'
    }
  }
  
  // 计算预览遮罩在原图中的位置
  // 获取原图在容器中的实际显示尺寸
  const container = originalImg.parentElement
  if (!container) return
  
  // 使用 requestAnimationFrame 确保 DOM 更新完成
  requestAnimationFrame(() => {
    const containerRect = container.getBoundingClientRect()
    const imageRect = originalImg.getBoundingClientRect()
    
    if (imageRect.width === 0 || imageRect.height === 0) {
      // 如果尺寸为0，延迟重试
      setTimeout(() => updatePreviewCrop(), 100)
      return
    }
    
    // 计算原图的缩放比例（contain 模式，保持宽高比，取较小值）
    // 容器可用尺寸（减去 padding）
    const containerPadding = 20 * 2 // 左右 padding
    const containerAvailableWidth = containerRect.width - containerPadding
    const containerAvailableHeight = containerRect.height - containerPadding
    
    const scaleX = containerAvailableWidth / naturalWidth
    const scaleY = containerAvailableHeight / naturalHeight
    const scale = Math.min(scaleX, scaleY) // contain 模式下使用统一的缩放比例
    
    // 计算图片实际显示的尺寸（使用 scale）
    const actualDisplayedWidth = naturalWidth * scale
    const actualDisplayedHeight = naturalHeight * scale
    
    // 计算图片在容器中的实际位置（居中显示）
    const imageLeft = (containerRect.width - actualDisplayedWidth) / 2
    const imageTop = (containerRect.height - actualDisplayedHeight) / 2
    
    // 计算预览区域在原图中的实际尺寸（像素）
    // 这个逻辑应该与实际页面中的裁剪逻辑完全一致
    let sourceWidth = 0
    let sourceHeight = 0
    let sourceX = 0
    let sourceY = 0
    
    if (naturalRatio > targetRatio) {
      // 图片较宽：按高度缩放，需要水平裁剪
      // 预览区域的高度 = 原图高度
      sourceHeight = naturalHeight
      // 预览区域的宽度 = 原图高度 * 目标比例
      sourceWidth = naturalHeight * targetRatio
      
      // 根据裁剪位置计算水平偏移
      if (cropPos.includes('left')) {
        sourceX = 0
      } else if (cropPos.includes('right')) {
        sourceX = naturalWidth - sourceWidth
      } else {
        // center
        sourceX = (naturalWidth - sourceWidth) / 2
      }
      sourceY = 0
    } else {
      // 图片较高：按宽度缩放，需要垂直裁剪
      // 预览区域的宽度 = 原图宽度
      sourceWidth = naturalWidth
      // 预览区域的高度 = 原图宽度 / 目标比例
      sourceHeight = naturalWidth / targetRatio
      
      // 根据裁剪位置计算垂直偏移
      if (cropPos.includes('top')) {
        sourceY = 0
      } else if (cropPos.includes('bottom')) {
        sourceY = naturalHeight - sourceHeight
      } else {
        // center
        sourceY = (naturalHeight - sourceHeight) / 2
      }
      sourceX = 0
    }
    
    // 将原图坐标转换为显示坐标（使用统一的scale）
    const maskLeft = sourceX * scale
    const maskTop = sourceY * scale
    const maskWidth = sourceWidth * scale
    const maskHeight = sourceHeight * scale
    
    // 确保白框不超出图片边界
    // 限制白框位置，确保不超出图片实际显示区域
    const clampedMaskLeft = Math.max(0, Math.min(maskLeft, actualDisplayedWidth - maskWidth))
    const clampedMaskTop = Math.max(0, Math.min(maskTop, actualDisplayedHeight - maskHeight))
    
    // 计算遮罩层（加暗未选中部分）
    // 使用 clip-path 创建一个"反向遮罩"，将白框外的部分加暗
    const maskLeftPercent = ((imageLeft + clampedMaskLeft) / containerRect.width) * 100
    const maskTopPercent = ((imageTop + clampedMaskTop) / containerRect.height) * 100
    const maskRightPercent = ((imageLeft + clampedMaskLeft + maskWidth) / containerRect.width) * 100
    const maskBottomPercent = ((imageTop + clampedMaskTop + maskHeight) / containerRect.height) * 100
    
    overlayStyle.value = {
      clipPath: `polygon(
        0% 0%,
        0% 100%,
        ${maskLeftPercent}% 100%,
        ${maskLeftPercent}% ${maskTopPercent}%,
        ${maskRightPercent}% ${maskTopPercent}%,
        ${maskRightPercent}% ${maskBottomPercent}%,
        ${maskLeftPercent}% ${maskBottomPercent}%,
        ${maskLeftPercent}% 100%,
        100% 100%,
        100% 0%
      )`,
    }
    
    // 设置预览遮罩的位置和大小（只显示边框，不显示背景图片）
    previewMaskStyle.value = {
      left: `${imageLeft + clampedMaskLeft}px`,
      top: `${imageTop + clampedMaskTop}px`,
      width: `${maskWidth}px`,
      height: `${maskHeight}px`,
    }
  })
}
```

### 1.3 监听器

```typescript
// 第 197-202 行
// 监听裁剪位置变化
watch(previewCropPosition, () => {
  nextTick(() => {
    updatePreviewCrop()
  })
})

// 第 204-216 行
// 监听图片预览变化
watch(imagePreview, () => {
  nextTick(() => {
    // 等待图片加载完成
    if (originalImageRef.value) {
      if (originalImageRef.value.complete) {
        updatePreviewCrop()
      } else {
        originalImageRef.value.addEventListener('load', updatePreviewCrop, { once: true })
      }
    }
  })
})

// 第 218-225 行
// 监听窗口大小变化，重新计算预览位置
if (typeof window !== 'undefined') {
  window.addEventListener('resize', () => {
    if (imagePreview.value) {
      updatePreviewCrop()
    }
  })
}
```

### 1.4 模板部分

```vue
<!-- 第 381-447 行 -->
<!-- 图片预览 -->
<div class="form-group">
  <label>图片预览</label>
  <div class="image-preview-container" v-if="imagePreview">
    <!-- 原图（尽量大，不拉伸） -->
    <img
      ref="originalImageRef"
      :src="imagePreview"
      alt="原图"
      class="image-preview-original"
      @load="updatePreviewCrop"
    />
    <!-- 遮罩层：将白框外的部分加暗 -->
    <div class="image-preview-overlay" :style="overlayStyle"></div>
    <!-- 预览区域（白色框框选的部分就是预览结果） -->
    <div class="image-preview-mask" :style="previewMaskStyle"></div>
  </div>
  <div v-else class="image-placeholder">暂无图片</div>
</div>
```

### 1.5 样式定义

```css
/* 第 670-679 行 */
.image-preview-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1;
  pointer-events: none;
}

/* 第 681-690 行 */
.image-preview-mask {
  position: absolute;
  overflow: hidden;
  border: 2px solid #ffffff;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.8), inset 0 0 0 1px rgba(0, 0, 0, 0.2);
  z-index: 1;
  background: transparent;
  pointer-events: none;
  /* 大小通过内联样式动态设置，保持3:4比例 */
}
```

---

## 2. SearchModal.vue - 搜索结果白框实现

### 2.1 当前实现（传统 border 方式）

```css
/* 第 770-780 行 */
.result-item {
  border: 2px solid var(--border-color);
  cursor: pointer;
  transition: all 0.2s;
  background: var(--bg-color);
}

.result-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
```

### 2.2 优化建议（使用伪元素）

如果需要优化为使用伪元素实现白框（避免边框影响聚焦区域判定），可以使用以下代码：

```css
.result-item {
  /* 聚焦区域：纯矩形，无边框，不影响内容判定 */
  position: relative;
  cursor: pointer;
  transition: all 0.2s;
  background: var(--bg-color);
}

/* 使用伪元素绘制白框，不影响聚焦区域 */
.result-item::before {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border: 2px solid var(--border-color);
  pointer-events: none;
  z-index: 1;
}

.result-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
```

---

## 功能说明

### EditItemModal.vue 遮罩功能

1. **遮罩层（overlay）**：
   - 使用 `clip-path: polygon()` 创建反向遮罩
   - 遮罩整个容器，但排除白框区域
   - 背景色：`rgba(0, 0, 0, 0.5)`，半透明黑色
   - z-index: 1

2. **白框（mask）**：
   - 使用绝对定位，动态计算位置和大小
   - 边框：2px 白色实线
   - 外阴影：`0 0 15px rgba(0, 0, 0, 0.8)`
   - 内阴影：`inset 0 0 0 1px rgba(0, 0, 0, 0.2)`
   - z-index: 1（与遮罩层同级，但通过 DOM 顺序确保在上方）

3. **位置计算**：
   - 考虑图片的 `object-fit: contain` 模式
   - 计算图片在容器中的实际显示位置和尺寸
   - 根据裁剪位置（center top、center center 等）计算白框位置
   - 确保白框不超出图片边界

### SearchModal.vue 白框功能

1. **实现方式**：
   - 使用 CSS 伪元素 `::before` 绘制白框
   - 白框绘制在元素外部（`top: -2px; left: -2px` 等）
   - 不影响聚焦区域的判定（`pointer-events: none`）

2. **优势**：
   - 聚焦区域是纯矩形，无边框
   - 白框通过伪元素绘制，不影响内容判定
   - 边框宽度不会遮挡聚焦区域的内容

---

## 技术要点

1. **clip-path 反向遮罩**：
   - 使用 `polygon()` 创建复杂的多边形路径
   - 通过路径定义遮罩区域，排除白框区域

2. **坐标转换**：
   - 从原图坐标转换为显示坐标
   - 考虑缩放比例（scale）
   - 考虑容器 padding 和图片居中位置

3. **边界处理**：
   - 使用 `Math.max()` 和 `Math.min()` 限制白框位置
   - 确保白框不超出图片边界

4. **响应式更新**：
   - 监听窗口大小变化
   - 监听图片加载完成
   - 监听裁剪位置变化

---

## 注意事项

1. **z-index 层级**：
   - 遮罩层和白框的 z-index 需要正确设置
   - 确保白框显示在遮罩层之上

2. **性能优化**：
   - 使用 `requestAnimationFrame` 确保 DOM 更新完成后再计算
   - 图片加载完成后再计算位置

3. **边界情况**：
   - 处理图片尺寸为 0 的情况
   - 处理容器不存在的情况
   - 处理图片未加载完成的情况

